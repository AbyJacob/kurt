# Copyright (C) 2012 Tim Radvan
#
# This file is part of Kurt.
#
# Kurt is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# Kurt is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with Kurt. If not, see <http://www.gnu.org/licenses/>.

"""
To add support for a new file format, write a new :class:`KurtPlugin` subclass::

    import kurt
    from kurt.plugin import Kurt, KurtPlugin

    class MyScratchModPlugin(KurtPlugin):
        def load(self, path):
            f = open(path)
            kurt_project = kurt.Project()
            # ... set kurt_project attributes ... #
            return kurt_project

        def save(self, path, kurt_project):
            f = open(path, "w")
            # ... save kurt_project attributes to file ...

    Kurt.register(MyScratchModPlugin())

Take a look at :mod:`kurt.scratch20` for a more detailed example.


List available plugins
~~~~~~~~~~~~~~~~~~~~~~

To get a list of the plugins registered with :class:`Kurt`:

    >>> kurt.plugin.Kurt.plugins
    {'scratch14': kurt.scratch14.Scratch14Plugin()}

You should see your plugin in the output, unless you forgot to :attr:`register
<Kurt.register>` it.


Notes
~~~~~

Some things to keep in mind:

* Most Scratch file formats have the *stage* as the base object -- so project
  attributes, such as the notes and the list of sprites, are stored on the
  stage object.

"""

from collections import OrderedDict

import kurt



class KurtPlugin(object):
    """Handles a specific file format.

    Loading and saving converts between a :class:`Project`, kurt's internal
    representation, and a file of this format.

    """

    name = "scratch14"
    """Short name of this file format, Python identifier style. Used internally
    by kurt.

    Examples: ``"scratch14"``, ``"scratch20.sprite"``, ``"byob3"``, ``"snap"``

    """

    display_name = "Scratch 2.0 Sprite"
    """Human-readable name of this file format. May be displayed to the user.
    Should not contain "Project" or "File".

    Examples: ``"Scratch 1.4"``, ``"Scratch 2.0 Sprite"``, ``"BYOB 3.1"``

    """

    extension = ".sb"
    """The extension used by this format, with leading dot.

    Used by :attr:`Project.load` to recognise its files.
    """

    has_stage_specific_variables = False
    """Whether the Project can have stage-specific variables and lists, in
    addition to global variables and lists (which are stored on the
    :class:`Project`).

    """

    def __init__(self):
        self.blocks = self.make_blocks()
        """The list of :class:`TranslatedBlockType` objects supported by this
        plugin, in the order they appear in the program's interface.

        Generated by the :attr:`make_blocks` function.

        """

        self.blocks_by_command = {}
        """Map of command names to :class:`TranslatedBlockType` objects.

        Unlike :attr:`Kurt.block_by_command`, only stores the first block with
        the given command.

        """
        for b in self.blocks:
            if b and b.command not in self.blocks_by_command:
                self.blocks_by_command[b.command] = b

    def __repr__(self):
        return self.__module__ + "." + self.__class__.__name__ + "()"

    # Override the following methods in subclass:

    def make_blocks(self):
        """Return a list of :class:`TranslatedBlockType` objects, which will be
        the value of the :attr:`blocks` property.

        This function is only called once.

        """
        raise NotImplementedError

    def load(self, path):
        """Load a project from a file with this format.

        :attr:`Project.path` will be set later. :attr:`Project.name` will be
        set to the filename of ``path`` if unset.

        The file at ``path`` is not guaranteed to exist.

        :param path: Path to the file, including the plugin's extension.
        :returns: :class:`Project`

        """
        raise NotImplementedError

    def save(self, path, project):
        """Save a project to a file with this format.

        :param path: Path to the file, including the plugin's extension.
        :param project: a :class:`Project`

        """
        raise NotImplementedError


class Kurt(object):
    """The Kurt file format loader.

    This class manages the registering and selection of file formats. Used by
    :class:`Project`.
    """

    plugins = OrderedDict()

    blocks = []

    @classmethod
    def register(cls, plugin):
        """Register a new :class:`KurtPlugin`.

        Once registered, the plugin can be used by :class:`Project`, when:

        * :attr:`Project.load` sees a file with the right extension

        * :attr:`Project.convert` is called with the format as a parameter

        """
        cls.plugins[plugin.name] = plugin

        new_blocks = filter(None, plugin.blocks)
        for tb in new_blocks:
            for other in cls.blocks:
                if (other.has_command(tb.command) or
                        other.has_command(tb._match)):
                    other._add_translation(tb)
                    break
            else:
                cls.blocks.append(kurt.BlockType([(plugin.name, tb)]))

    @classmethod
    def get_plugin(cls, name=None, **kwargs):
        """Returns the first format plugin whose attributes match kwargs.

        For example::

            get_plugin(extension="scratch14")

        Will return the :class:`KurtPlugin` whose :attr:`extension
        <KurtPlugin.extension>` attribute is ``"scratch14"``.

        The :attr:`name <KurtPlugin.name>` is used as the ``format`` parameter
        to :attr:`Project.load` and :attr:`Project.save`.

        :raises: :class:`ValueError` if the format doesn't exist.

        :returns: :class:`KurtPlugin`

        """
        if 'extension' in kwargs:
            kwargs['extension'] = kwargs['extension'].lower()
        kwargs["name"] = name

        for plugin in cls.plugins.values():
            for name in kwargs:
                if getattr(plugin, name) != kwargs[name]:
                    break
            else:
                return plugin

        raise ValueError, "Unknown format %r" % kwargs

    @classmethod
    def block_by_command(cls, command):
        """Return a list of blocks with the given :attr:`command`."""
        matches = []
        for block in cls.blocks:
            if block.has_command(command):
                matches.append(block)
        return matches

    @classmethod
    def block_by_text(cls, text):
        """Return a list of blocks loosely matching the given :attr:`text`."""
        text = kurt.BlockType._strip_text(text)
        matches = []
        for block in cls.blocks:
            for tb in block._translations.values():
                if kurt.BlockType._strip_text(tb.text) == text:
                    matches.append(block)
        return matches

